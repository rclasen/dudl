#!/usr/bin/perl -w

# $Id: dudl-rename,v 1.5 2009-12-03 10:44:32 bj Exp $

#
# Copyright (c) 2008 Rainer Clasen
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms described in the file LICENSE included in this
# distribution.
#

=pod

=head1 NAME

dudl-rename - rename MP3 files, set ID tags and strip unwanted headers

=head1 SYNOPSIS

 dudl-rename [<opts>] <job1> [...]

=head1 DESCRIPTION

dudl-rename processes files generated by dudl-rengen. These files carry
enough information to set "proper" names for your MP3s. 

See I<Dudl::Job::Rename> for a description of the input job format.

The resulting MP3s are placed in a subdirectory.

New file- and directory names are consturcted by I<Dudl::Naming::Default>
or what ever naming module you have selected in your config.

RIFF headers (from .wav files) are stripped automatically.

=head1 OPTIONS

=over 4

=cut

use strict;
use Getopt::Long;
use Carp;
use MP3::Tag;
use MP3::Offset;
use Dudl::Config;
use Dudl::Job::Rename;
use Dudl::Job::Archive;
use Data::Dumper;

my 
$VERSION = '0.1.24';

sub usage {
	my $fh = shift;

	print $fh "$0 - [options] [job files]
renames MP3 files and sets their ID3 tag
options:
 --[no]copy    copy file to new name (default: on)
 --[no]delete  delete orgiginal file after copy (default: off)
 --[no]v1      set v1 tag on new copy (default on)
 --[no]v2      set v2 tag on new copy (default off) (untested)

 --[no]info    generate archive job file  (default: on)
 --[no]test    dry run - just test job file (default: off)
 --quiet       don't be so verbose
 --dstdirs     show directories that are to be generated
 --checkdb     contact DB for some checks
 --ifile <n>   name of archive job file
 --indir <i>   where to search input files
 --outdir <o>  where to place renamed files

 --help        this help

Notes:
 - RIFF headers are stripped
 - v1/v2 tags are stripped when disabled
 - info files may get used for dudl database imports
";
}

my $dudl = new Dudl::Config;

=pod

=item B<-c>, B<--copy>

Copy files to new subdirectory leaving the original intact. 

=item B<--nocopy>

Do not copy files. Usefull in combination with --info.

=cut
my $opt_copy = 1;

=pod

=item B<--v1>, B<--nov1>

shall ID3v1 Tags be added to the MP3 files.

=cut
my $opt_v1 = $dudl->conf("write_v1");

=pod

=item B<--v2>, B<--nov2>

shall ID3v2 Tags be added to the MP3 files.

=cut
my $opt_v2 = $dudl->conf("write_v2");

=pod

=item B<--delete>, B<--nodelete>

shall files be deleted after copying them. Be careful - you can't reuse
the current jobfile for a retry.

=cut
my $opt_delete = 0;

=pod

=item B<--test>

make a dry run to test the job file. Shortcut for --nocopy --noinfo
--nodelete

=cut
my $opt_test = 0;

=pod

=item B<--quiet>

don't be so verbose

=cut
my $opt_quiet = 0;

=pod

=item B<--dstdirs>

show directories that are to be generated

=cut
my $opt_dstdirs = 0;

=pod

=item B<--info>, B<--noinfo>

shall an Info file for processing with dudl-scan be created. This file is
similar to the input job File. It's syntax is described in
I<Dudl::Job::Archive>. Without such an archive jobfile information might
get lost since ID tags and filenames cannot carry all the desired
information. This file is placed in the resulting directory.

=cut
my $opt_info = $dudl->conf("write_job");

=pod

=item B<--name=aname>

name of the above mentioned archive jobfile. Do not change it unless you
want to break dudl-scan.

=cut
my $opt_ifile = $dudl->conf("write_jname") || "TRACKS.dudl_archive";

=pod

=item B<--outdir>=I<path>

Path where files are created. The subdirectory for the album is created
below this directory. Renamed MP3s and the jobfile are put into the album
directory. The Default is picked from the config (which in turn defaults
to the current working directory).

=cut
my $opt_outdir = $dudl->conf("write_dir") || ".";

=pod

=item B<--checkdb>

With this option dudl-rename connects to your dudl database to check 
artist name syntax and duplicate albums.

=cut
my $opt_checkdb = $dudl->conf("ren_checkdb") || 0;

my $opt_rfile = $dudl->conf("ren_jname") || "TRACKS.dudl_rename";

my $opt_help = 0;
my $needhelp = 0;

if( ! GetOptions(
	"copy|c!"		=> \$opt_copy,
	"delete!"		=> \$opt_delete,
	"v1!"			=> \$opt_v1,
	"v2!"			=> \$opt_v2,
	"info!"			=> \$opt_info,
	"test!"			=> \$opt_test,
	"quiet!"		=> \$opt_quiet,
	"dstdirs!"		=> \$opt_dstdirs,
	"checkdb!"		=> \$opt_checkdb,
	"name|n=s"		=> \$opt_ifile,
	"outdir=s"		=> \$opt_outdir,
	"help!"			=> \$opt_help,
) ){
	$needhelp++;
}

if( $opt_help ){
	&usage( \*STDOUT );
	exit 0;
}

if( ! $opt_v1 && ! $opt_v2 ){
	print STDERR "you have no IDtag version selected\n";
	$needhelp++;
}

if( $#ARGV < 0 ){
	print STDERR "need at least one job file\n";
	$needhelp++;
}

if( $needhelp ){
	&usage( \*STDERR );
	exit 1;
}

if( $opt_test ){
	$opt_info = 0;
	$opt_copy = 0;
	$opt_delete = 0;
}

my $dudldb;
if( $opt_checkdb && eval "require Dudl::DB" ){
	$dudldb = "Dudl::DB"->new( @_ );
}


my $nam = $dudl->naming;
my $job = new Dudl::Job::Rename( naming	 => $nam );
foreach my $f ( @ARGV ){
	$f .= "/".$opt_rfile if -d $f;
	$job->read( $f ) || die "error: $!";
}
$job->order;
$job->rewind;

use vars '$tmpdir';
$tmpdir = $opt_outdir ."/.dudl-rename-$$";
END { 
	&rmtree( $tmpdir ) or warn "failed to unlink $tmpdir: $!";
}

my( $oalb, $onum );
my( $dir, $out );
my $err = 0;
while( my($alb,$fil,$tit) = $job->next ){
	if( !defined($oalb) || $oalb != $alb ){
		# finish old album:
		if( $out ){
			&finish( $out, $tmpdir, $dir ) || $err++;
		}
		# start new one
		print "album type=", $alb->{type},": '", 
			$alb->{name}, "' ...\n" unless $opt_quiet;
		&checkdb_album( $alb ) || $err++;
		$oalb = $alb;
		$onum = 0;

		$out = new Dudl::Job::Archive( naming => $nam );
		$out->add_album( %$alb ) or $err++;

		$dir = $opt_outdir ."/". $nam->dir( $out->album );
		print $dir,"\n" if $opt_dstdirs;
		if( ! $opt_test && ! mkdir( $tmpdir, 0777 ) ){
			print STDERR "ERROR: cannot mkdir: $!\n";
			$err++;
		}
	}

	# TODO: check DB genres

	$out->add_file( %$fil ) or $err++;
	$out->file->{mp3} = $nam->fname( $alb, $tit );

	if( ++$onum != $tit->{num} ){
		print STDERR "ERROR: unexpected title number: ", 
			$tit->{num}, "\n";
		$err++;
	}
	$onum = $tit->{num};

	$out->add_title( %$tit ) or $err++;

	&copy_file( $fil->{dir}.$fil->{mp3}, $tmpdir, $out ) || $err++;
}
&finish( $out, $tmpdir, $dir ) || $err++;

if( $err ){
	print STDERR "ERROR: aborting due to above errors\n";
	exit 1;
}	
$tmpdir = undef;

if( $opt_delete ){
	print "deleting input files...\n" unless $opt_quiet;
	$job->rewind;
	while( my($alb,$fil,$tit) = $job->next ){
		unlink( $fil->{dir}.$fil->{mp3} ) 
			|| warn "unlink failed: $!";
	}
}


exit 0;

sub checkdb_album {
	my( $alb ) = @_;

	return 1 unless $dudldb;
	my $db = $dudldb->db;

	my $album = $db->quote( $alb->{name}, 1 ); # TODO: DBI::CHAR );
	my $artist = $db->quote( $alb->{artist}, 1 ); # TODO: DBI::CHAR );

	my( $artistid )= $db->selectrow_array( 
		"SELECT ".
                        "id ".
                "FROM mus_artist ".
                "WHERE ".
                        "LOWER(nname) = LOWER($artist) ".
                "LIMIT 1" );
	return 1 unless $artistid;

	my( $albumid ) = $db->selectrow_array( 
		"SELECT ".
			"id ".
		"FROM mus_album ".
		"WHERE ".
			"LOWER(album) = LOWER($album) ".
			"AND artist_id = $artistid ".
		"LIMIT 1");
	if( $albumid ){
		print STDERR "ERROR: album already present as id $albumid\n";
		return;
	}

	return 1;
}

sub rmtree {
	my $dir = shift;

	return 1 unless $dir && -d $dir;

	local *D;
	opendir( D, $dir ) or return;
	unlink grep { $_ = "$dir/$_"; ! /\/\.\.?$/ } readdir(D);
	closedir(D);

	rmdir $dir or return;

	return 1
}

sub finish {
	my( $out, $tmpdir, $dir ) = @_;

	&write_info( $out, $tmpdir ) || return;
	if( -d $dir ){
		print STDERR "ERROR: directory already exists: $dir\n";
		$opt_test || &rmtree( $tmpdir );
		return;

	} elsif( ! $opt_test && ! rename $tmpdir, $dir ){
		print STDERR "ERROR: cannot rename dir to $dir: $!";
		&rmtree( $tmpdir );
		return;
	}

	return 1;
}




sub write_info {
	my( $out, $dir ) = @_;

	return 1 unless $opt_info;
	if( ! $out->album ){ # TODO: is this necessary?
		print STDERR "ERROR: missing album\n";
		return;
	}

	print "generate archive jobfile ...\n" unless $opt_quiet;

	local *OUT;
	if( ! open( OUT, ">$dir/$opt_ifile" ) ){
		print STDERR "ERROR: open failed: $!\n";
		return;
	}
	$out->write( \*OUT );
	close( OUT );

	return 1;
}

sub copy_file {
	my( $ifile, $dir, $out ) = @_;

	my $fname = $out->file->{mp3};
	printf " %2d %s...\n", $out->title->{num}, $ifile unless $opt_quiet;
	return 1 unless $opt_copy;

	my $mp = new MP3::Offset( $ifile );
	
	# file anlegen
	local *OUT;
	if( ! open( OUT, ">$dir/$fname" ) ){
		print STDERR "ERROR: cannot open output: $!\n";
		return;
	}

	local *IN;
	if( ! open( IN, $ifile ) ){
		print STDERR "ERROR: cannot open source $!\n";
		return;
	}
	seek( IN, $mp->offset, 0 );

	# copy data
	my $buf;
	if( ! read( IN, $buf, $mp->dsize ) ){
		print STDERR "ERROR: cannot read: $!\n";
		return;
	}
	print OUT $buf;
	close( IN );
	close( OUT );

	if( $opt_v2 && ! &write_v2( "$dir/$fname", $out->album, $out->title )){
		print STDERR "ERROR: cannot write id3v2 tag\n";
		return;
	}

	if( $opt_v1 && ! &write_v1( "$dir/$fname", $out->album, $out->title )){
		print STDERR "ERROR: cannot write id3v2 tag\n";
		return;
	}

	return 1;
}


sub write_v1 {
	my $fname = shift;
	my $album = shift;
	my $title = shift;
	
	my $t = new MP3::Tag( $fname ) || return;
	my $v1 = $t->new_tag( 'ID3v1' ) || return;

	$v1->song( $title->{name} );
	$v1->artist( $title->{artist} );
	$v1->album( $album->{name} );
	$v1->comment( $title->{cmt} );
	$v1->year( $album->{year} );
	$v1->genre( $title->{genres} );
	$v1->track( $title->{num} );

	$v1->writeTag() || return;
	$t->close();

	return 1;
}

sub write_v2 {
	my $fname = shift;
	my $album = shift;
	my $title = shift;
	
	my $t = new MP3::Tag( $fname ) || return; 
	$t->{ID3v2}->remove_tag if exists $t->{ID3v2};

	my $v2 = $t->new_tag( 'ID3v2' ) || return;

	sub addf {
		my( $tag, $frame, $val ) = @_;
		$tag->add_frame( $frame, $val ) if defined $val && $val;
	}
	&addf( $v2, "TIT2", $title->{name} );
	&addf( $v2, "TPE1", $title->{artist} );
	&addf( $v2, "TALB", $album->{name} );
	&addf( $v2, "COMM", $title->{cmt} );
	&addf( $v2, "TYER", $album->{year} );
	&addf( $v2, "TCON", $album->{genres} );
	&addf( $v2, "TRCK", $album->{num} );

	$v2->write_tag() || return;
	$t->close();
	return 1;
}

__END__

=head1 EXAMPLES

process "job1.ren": copy files to new names (stripping an existing RIFF
and/or ID3v2 tag) and add an ID3v1 Tag:

 dudl-rename --noinfo --nov2 --v1 job1.ren

process "job2.ren": only creat an Archive job file:

 dudl-rename --info --nocopy job2.ren


=head1 FILES

=item  F</etc/dudl.rc>, F<$HOME/.dudlrc>

The config for all dudl applications. See I<dudlrc(5)> for details.
dudl-rename uses these keys:

=over 4

=item naming (string)

Dudl::Naming:: module to use for constructing file- and directory names.

=item ren_checkdb (bool)

default for --checkdb

=item write_v1 (bool)

default for --v1

=item write_v2 (bool)

default for --v2

=item write_job (bool)

default for --info

=item write_jname (string)

default for --name

=back

=item write_dir (string)

default for --outdir

=back

=head1 SEE ALSO

I<dudl-rengen(1)>, 
I<dudlrc(5)>, 
I<Dudl::Naming::Default>, 
I<Dudl::Job::Rename>,
I<Dudl::Job::Archive>.

=head1 AUTHOR

Rainer Clasen

=cut

